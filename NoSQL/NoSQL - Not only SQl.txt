NoSQL - Not only SQl
=> database with flexibility
=> database with scalability
=> database with high availability

SQl vs NoSQL
1. Schema(SQL) - Fixed and predefined
   Schema(NoSQL) - Flexible, Schema-less

2. Scalability(SQL) - Vertically(adding more power to single server)
   Scalability(NoSQL) - Horizontally(adding more servers)

3. Data Storage(SQL) - Structured tables with rows and columns
   Data Storage(NoSQL) - key-value, document, graph, wide-columns

4. Query language(SQL) - SQL (Structured query language)
   Query language(NoSQL) - Varies (No standard query language)

5. ACID compliance (SQL) - Strong ACID compliance
   ACID compliance (NoSQL) - relaxed for high scalability (Some NoSQL DBs support ACID)

6. Best for(SQL) - Structured data with relationships (banking,erp.)
   Best for(NoSQL) - Unstructured or semistructured (IOT,social media)

Types of NoSQL Database -
1. Key-value Stores(eg. Redis, DynamoDB) - 
	-> Simple key-value pairs(like dictionary)
	-> used in caching, session management

2. Document Stores(eg. MongoDB, CouchDB)
	-> JSON-like documents(flexible schema)
	-> Content management, catalogs
	
3. Graph Database(eg. Neo4j, ArangoDB)
	-> Nodes and edges for relationships
	-> fraud detection, social networks

4. Wide columns stores(eg. Cassandra,HBase)
	-> Tables with flexible columns
	-> Big data, time-series data


When to use NoSQl vs Relational database?
We can us NSQl -
	1. We need high scalability
	2. Distibuted architecture
	3. Data structure changes rquently
	4. We reuire high-speed read/write opeations
We can use Relational database
	1. Data integrity  and consistency is critical
	2. We need complex queries and transaction

Redis -
	1. Its open source
	2. It has a free version
	3. It is easy to install and can be used locally
	4. No clou dependency
	5. It is fast (stored data in memory)
	6. Can be used for caching, session storage, real-tim analytics

mac - 
brew install redis
brew services start redis

start redis command line interface - 
redis-cli

Redis is in-memory data structure store that can be used as a database, cache, and message broker. 
It supports multiple data structure such as -
1. Strings
2. Hashes
3. Lists
4. Sets
5. Stored Sets
6. Bitmaps
7. Geospatial indexes
8. HyperLogLogs

Use cases
1. Session storage - websites use redis to store user session data for fast retrieval
2. Caching - Frequently accessed data can be stored in redis to reduce database queries
3. Real-time messaging - chat applications use redis as a message broker


Features -
1. In-memory storage - data stored in RAM, making read and write operations extremely fast
2. Persistence - Redis provides option to dump data to disk.
3. Data structure - supports strings, hashes , lists..
4. Replication - Master-slave replication allows data to be copied to multiple servers.
5. Pub/Sub Messaging - Redis can act as a message broker with its publish/subscribe mechanism


NoSQL - DynamoDB and Redis

Similaraties
1. Both are NoSQL database
2. Both uses Key-Value store
3. Both are High scalable
4. Both are optimized for fast read/writes but Redis can be used for ultra-fast read/writes
5. AWS DynamoDB (fully managed) , AWS ElastiCache for Redis(Managed)
6. Both supports Replication
7. Both supports caching (Redis have buil-in caching by default)

Differences -
1. DynamoDB is a persistent NoSQL Database as it stores data persistently on SSDs
   Redis is In-memory data store as it stores data in RAM (Optional persistent)
2. DynamoDB is schema less, supports key-value and document storage
   Redis supports key-value and various data structure (Lists, Hashes, Sets, Sorted sets etc.)
3. DynamoDB supports complex queries(indexes, filtering, conditional updates)
   Redis primarily key-based lookup
4. DynamoDB has millisecond latency (good for large-scale applications)
   Redis has microsecond latency (extremely fast reads/writes)
5. DynamoDB is always persistent
   Redis is by default volatile, but can be persisted
6. DynamoDB supports ACID transactions
   Redis supports basic transactions
7. DynamoDB - Large scale applications requiring reliable persistent storage
   Redis - Application needing fast in-memory access


Use cases of DynamoDB -
1. E-commerce order management - to store users orders and track inventory
2. User Profiles & Metadata - user preferences, game progress, session history
3. IOT data storage - capture sensor data from IOT device
4. Financial transaction - For ledger based systems where data consistency is important

Use cases of Redis -
1. Caching API responses - Cache frequently accessed API responses to reduce database load. ex- a news website caches trending artilcles
2. session management - store user session for quick authentication. Ex- A login system stores session tokens in redis for quick lookup
3. Real time leaderboards - uses Sorted sets to track top players dynamically.
4. Rate limiting - Limit the number of requests per user (API rate limiting). ex- An API allows only 100 requests per minute per user
5. Pub/Sub messaging - Redis can act as a message broker for real time chat applications. ex. A stock trading platform sends price updates via redis pub/sub.



data structures -
1. String
set name "Ajay"
set age 22
get name
get age
set counter 10
incr counter
decr counter
append name "Sharma"

Use case 1 - User login token
* Lets say user Id is 123, and their token is "abc123"
set user:123:token "abc123"
get user:123:token
* This is like saving a small piece of data (the login token) for a user
* In any web/mobile app where users log in.
	* When a user logs in, the app generates a session token or JWT token to remember them.
	* This token is stored in Redis for quick lookup.
Why Redis?
	* Redis is super fast (in-memory).
	* Ideal for checking if a token is valid without hitting a slow database.
Example:
	* You open Amazon on your phone.
	* The app sends your token to the server.
Server checks:
	* GET user:your_user_id:token
	* If valid, you're logged in. If expired or not found, you're asked to log in again.

Use Case 2: Page View Counter
You want to count how many times the homepage is viewed.
We'll use a counter key like page:home:views.
	* INCR page:home:views
	* INCR page:home:views
	* GET page:home:views


Use Case 3: Cache API Result with Expiry
You want to cache weather data that expires after 1 hour.
Save "sunny" weather info for Delhi, with auto-expiry in 3600 seconds (1 hour).
	* SET weather:delhi "sunny" EX 3600
	* GET weather:delhi
	* TTL weather:delhi

======================================================================================

2. Hashes - hashes let you store multiple fields under a single key. Good for storing objects like a user profile
	* HSET user:1001 name "joy" age "22" email "joy@abc.com"
	* HGET user:1001 name
	* HGETALL user:1001
	* HGET user:1001 age
	* HDEL user:1001 age
	* HSET user:1001 age "31"

Use case 1 - You're building a user profile for a web app
	* You want to store - name , city
		* HSET user:123 name "Alice" city "Mumbai"
	* Get one field - name
		* HGET user:123 name
	* Get full profile
		* HGETALL user:123

Use case 2 - You're building a e-commerce app and want to cache product details.
	* Store : Price, Stock
		* HSET product:900 price "2500" stock "20"
	* Check product price
		* HSET product:900 stock "19"
	* Get complete product info
		* HGETALL product:900

use case 3 - Store app settings/Config
	* You want to store application-wide settings, like theme or font style
	* Add config
		* HSET settings:app theme "dark" font "arial"
	* Read one setting
		* HGET settings:app theme
	* Change the setting
		* HSET settings:app theme "light"
	* view all settings
		* HGETALL settings:app

======================================================================================

3. Lists - 
	* An ordered collection of string
	* It is like a queue or a to-do list
	* We can push or pop items from the left or right
	* Redis Lists are automatically created when you add your first item.
	
		* LPUSH mylist "item1"
		* LPUSH mylist "item2"
		* LPUSH mylist "item3"

	* To view full list
		* LRANGE mylist 0 -1

	* RPUSH mylist "item4"
		* RPUSH mylist "item4"

	* Remove from left
		* LPOP mylist

	* Remove from right
		* RPOP mylist

	* Get specific item 
		* LINDEX mylist 1

	* Trim list to specific length
		* LTRIM mylist 0 1


Use case 1 - Recent user activities
	* Store the last 5 things a user did on your app (clicked a button, watch a video etc..)
	* Push recent actions to the list
		* LPUSH user:123:activities "watched_video"
		* LPUSH user:123:activities "clicked_profile"
		* LPUSH user:123:activities "liked_post"

	* Check the list
		* LRANGE user:123:activities 0 -1

	* keep only the last 5 actions
		* LTRIM user:123:activities 0 4


Use case 2 - Task queues/ Background jobs
	* Apps may have background jobs (like sending emails, processing uploads). We can queue them with redis lists
	* Push jobs to queue
		* RPUSH task_queue "send_email:101"
		* RPUSH task_queue "generate_pdf:102"

	* Worker pulls the next job
		* LPOP task_queue


Use case 3 - Chat message queue
	* in a chat app, we want to store recent message between users
	* add messages
		* RPUSH chat:alice:bob "Hi Bob!"
		* RPUSH chat:alice:bob "How are you?"

	* get all messages
		* LRANGE chat:alice:bob 0 -1

	* get last message only
		* LINDEX chat:alice:bob -1

======================================================================================

4. Set-
	* An unordered collection of unique strings (no duplicates allowed)
	* it can be useful when we need to check membership, remove duplicates,
	  or do set operations like union, intersection and difference
	* create a set
		* sadd myset "apple"
		* sadd myset "oranges"
		* sadd myset "cherry"
		* sadd myset "apple"

	* view all members of a set
		* smembers myset

	* check if an item exists
		* sismember myset "apple"

	* remove an item
		* srem myset "apple"

	* get number of items
		* scard myset

	* Set Operations (with two sets)
		* sadd set1 "apple" "banana" "cherry"
		* sadd set2 "banana" "cherry" "date"

	* Intersection (common items)
		* sinter set1 set2

	* Union (all unique items)
		* sunion set1 set2

	* difference (items in set1 but not in set2)
		* sdiff set1 set2
